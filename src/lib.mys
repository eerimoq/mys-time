class Time:
    """Time in seconds and nanoseconds.

    """

    def __init__(self,
                 seconds: int,
                 nanoseconds: int):
        self.seconds: int = seconds
        self.nanoseconds: int = nanoseconds

    def __eq__(self, other: Time) -> bool:
        return (self.seconds == other.seconds
                and self.nanoseconds == other.nanoseconds)

    def __ne__(self, other: Time) -> bool:
        return not (self == other)

    def __gt__(self, other: Time) -> bool:
        if self.seconds > other.seconds:
            return True
        elif self.seconds == other.seconds:
            return self.nanoseconds > other.nanoseconds
        else:
            return False

    def __ge__(self, other: Time) -> bool:
        return self > other or self == other

    def __lt__(self, other: Time) -> bool:
        return not (self >= other)

    def __le__(self, other: Time) -> bool:
        return not (self > other)

    def __iadd__(self, other: Time):
        self.seconds += other.seconds
        self.nanoseconds += other.nanoseconds

        if self.nanoseconds >= 1_000_000_000:
            self.seconds += 1
            self.nanoseconds -= 1_000_000_000

    def __isub__(self, other: Time):
        self.seconds -= other.seconds
        self.nanoseconds -= other.nanoseconds

        if self.nanoseconds < 0:
            self.seconds -= 1
            self.nanoseconds += 1_000_000_000

    def __add__(self, other: Time) -> Time:
        result = Time(self.seconds, self.nanoseconds)
        result += other

        return result

    def __sub__(self, other: Time) -> Time:
        result = Time(self.seconds, self.nanoseconds)
        result -= other

        return result

class DateTime:
    """Date and time.

    """

    def __init__(self,
                 year: int,
                 month: int,
                 day: int,
                 hour: int,
                 minute: int,
                 second: int):
        self.year: int = year
        self.month: int = month
        self.day: int = day
        self.hour: int = hour
        self.minute: int = minute
        self.second: int = second

    def from_time(time: Time) -> DateTime:
        """Create a DateTime object from given UTC time.

        """

        '''mys-embedded-c++
        time_t t;
        struct tm tm;

        t = time.seconds;

        if (std::gmtime_s(&t, &tm) == NULL) {
            throw ValueError("gmtime");
        }
        '''

        return DateTime(tm.tm_year,
                        tm.tm_month,
                        tm.tm_mday,
                        tm.tm_hour,
                        tm.tm_minute,
                        tm.tm_second)

    def to_time(self) -> Time:
        """Create a Time object in UTC from this date and time.

        """

        return Time(0, 0)

@test
def test_time():
    time = Time(5, 1)
    assert_eq(time.seconds, 5)
    assert_eq(time.nanoseconds, 1)

@test
def test_datetime_new():
    datetime = DateTime(2020, 9, 14, 19, 1, 34)
    assert_eq(datetime.year, 2020)
    assert_eq(datetime.month, 9)
    assert_eq(datetime.day, 14)
    assert_eq(datetime.hour, 19)
    assert_eq(datetime.minute, 1)
    assert_eq(datetime.second, 34)

@test
def test_datetime_from_time():
    datetime = DateTime.from_time(Time(1600000000, 0))
    assert_eq(datetime.year, 2020)
    assert_eq(datetime.month, 9)
    assert_eq(datetime.day, 14)
    assert_eq(datetime.hour, 19)
    assert_eq(datetime.minute, 1)
    assert_eq(datetime.second, 34)

@test
def test_datetime_to_time():
    datetime = DateTime(2020, 9, 14, 19, 1, 34)
    time = datetime.to_time()
    assert_eq(time.seconds, 1600000000)
    assert_eq(time.nanoseconds, 0)
